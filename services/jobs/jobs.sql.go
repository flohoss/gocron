// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: jobs.sql

package jobs

import (
	"context"
)

const createJob = `-- name: CreateJob :one
INSERT INTO
    jobs (id, name, cron)
VALUES
    (?, ?, ?) RETURNING id, name, cron
`

type CreateJobParams struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Cron string `json:"cron"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, createJob, arg.ID, arg.Name, arg.Cron)
	var i Job
	err := row.Scan(&i.ID, &i.Name, &i.Cron)
	return i, err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs
WHERE
    id = ?
`

func (q *Queries) DeleteJob(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteJob, id)
	return err
}

const getJob = `-- name: GetJob :one
SELECT
    id, name, cron
FROM
    jobs
WHERE
    id = ?
`

func (q *Queries) GetJob(ctx context.Context, id string) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJob, id)
	var i Job
	err := row.Scan(&i.ID, &i.Name, &i.Cron)
	return i, err
}

const listJobs = `-- name: ListJobs :many
SELECT
    id, name, cron
FROM
    jobs
ORDER BY
    name
`

func (q *Queries) ListJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, listJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(&i.ID, &i.Name, &i.Cron); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsCommandsEnvsRunsAndLogs = `-- name: ListJobsCommandsEnvsRunsAndLogs :many
SELECT
    jobs.id, jobs.name, jobs.cron,
    commands.id, commands.job_id, commands.command,
    envs.id, envs.job_id, envs."key", envs.value,
    runs.id, runs.job_id, runs.status_id, runs.start_time, runs.end_time
FROM
    jobs
    JOIN commands ON jobs.id = commands.job_id
    JOIN envs ON jobs.id = envs.job_id
    JOIN runs ON jobs.id = runs.job_id
WHERE
    jobs.id = ?
ORDER BY
    jobs.name
`

type ListJobsCommandsEnvsRunsAndLogsRow struct {
	Job     Job     `json:"job"`
	Command Command `json:"command"`
	Env     Env     `json:"env"`
	Run     Run     `json:"run"`
}

func (q *Queries) ListJobsCommandsEnvsRunsAndLogs(ctx context.Context, id string) ([]ListJobsCommandsEnvsRunsAndLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, listJobsCommandsEnvsRunsAndLogs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsCommandsEnvsRunsAndLogsRow
	for rows.Next() {
		var i ListJobsCommandsEnvsRunsAndLogsRow
		if err := rows.Scan(
			&i.Job.ID,
			&i.Job.Name,
			&i.Job.Cron,
			&i.Command.ID,
			&i.Command.JobID,
			&i.Command.Command,
			&i.Env.ID,
			&i.Env.JobID,
			&i.Env.Key,
			&i.Env.Value,
			&i.Run.ID,
			&i.Run.JobID,
			&i.Run.StatusID,
			&i.Run.StartTime,
			&i.Run.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsWithLatestRun = `-- name: ListJobsWithLatestRun :many
WITH
    latest_runs AS (
        SELECT
            job_id,
            MAX(id) AS max_run_id
        FROM
            runs
        GROUP BY
            job_id
    )
SELECT
    jobs.id, jobs.name, jobs.cron,
    runs.id, runs.job_id, runs.status_id, runs.start_time, runs.end_time
FROM
    jobs
    JOIN latest_runs lr ON jobs.id = lr.job_id
    JOIN runs ON lr.max_run_id = runs.id
ORDER BY
    jobs.name
`

type ListJobsWithLatestRunRow struct {
	Job Job `json:"job"`
	Run Run `json:"run"`
}

func (q *Queries) ListJobsWithLatestRun(ctx context.Context) ([]ListJobsWithLatestRunRow, error) {
	rows, err := q.db.QueryContext(ctx, listJobsWithLatestRun)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsWithLatestRunRow
	for rows.Next() {
		var i ListJobsWithLatestRunRow
		if err := rows.Scan(
			&i.Job.ID,
			&i.Job.Name,
			&i.Job.Cron,
			&i.Run.ID,
			&i.Run.JobID,
			&i.Run.StatusID,
			&i.Run.StartTime,
			&i.Run.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJob = `-- name: UpdateJob :exec
UPDATE jobs
SET
    name = ?,
    cron = ?
WHERE
    id = ?
`

type UpdateJobParams struct {
	Name string `json:"name"`
	Cron string `json:"cron"`
	ID   string `json:"id"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) error {
	_, err := q.db.ExecContext(ctx, updateJob, arg.Name, arg.Cron, arg.ID)
	return err
}
